:page-layout: default
:page-title: Mcdoc
:page-parent: Home
:page-nav_order: 1

Mcdoc is a schema format for describing data structures used by Minecraft, including its CODECs, JSONs, and NBTs.

== Project Structure

The root folder of a mcdoc project must contain a `pack.mcmeta` file and a `mcdoc` folder, where all mcdoc files are stored.
The file content of `pack.mcmeta` is not concerned by the mcdoc specification.

.File structure
====
[source]
----
Root/
	mcdoc/
		bar/
			mod.mcdoc
			qux.mcdoc
		foo.mcdoc
	pack.mcmeta
----
====

== Syntax

:plus: pass:n[^pass:[+]^]
:star: pass:n[^pass:[*]^]

[[tb-syntax-syntax]]
.Syntax syntax
|===
|Symbol |Meaning

|`str` |Literal `str`
|A{star} |A repeated zero or more times
|A{plus} |A repeated one or more times
|A^?^ |A repeated zero or one times
|A \| B |Either A or B
|++[++`A` `B` `C`++]++ |One of the literals `A`, `B`, or `C`
|++[++`A`-`Z`++]++ |Any literal from `A` to `Z`
|(A) |General grouping
|~not~A |Anything not A
|A~pass:n[lookahead: B]~ |A followed by B, but only consumes A
|<<tb-syntax-syntax,NAME>> |A referenced <<token-rule>>
|<<tb-syntax-syntax,_Name_>> |A referenced <<parser-rule>>
|===

[[token-rule,token rule]]
A token rule syntax cannot have any whitespaces (spaces, tabs, CRs, or LFs) or tokens in between the individual parts.

[[parser-rule,parser rule]]
A parser rule syntax can have whitespaces and <<t-comments>> in between.

=== File Structure

****
**SYNTAX**

[[s-file,_File_]]
_File_:: (<<s-dispatch>> | <<s-enum>> | <<s-struct>> | <<s-type-alias>> | <<s-use>> | <<s-inject>>){star}

****

=== Common Syntax

****
**SYNTAX**

[[s-prelim,_Prelim_]]
_Prelim_:: <<t-doc-comments>> <<s-attributes>>

'''
**SYNTAX (TOKEN)**

[[t-comments,COMMENTS]]
COMMENTS:: <<t-comment>>{star}

[[t-comment,COMMENT]]
COMMENT:: `//` ~pass:n[lookahead: ~not~`/`]~ (~not~<<t-eol>>){star} (<<t-eol>> | <<t-eof>>)

[[t-eol,EOL]]
EOL:: End of line: CR (Unicode `U+000D`) or LF (Unicode `U+000A`).

[[t-eof,EOF]]
EOF:: End of file.

[[t-doc-comments,DOC_COMMENTS]]
DOC_COMMENTS:: <<t-doc-comment>>{star}

[[t-doc-comment,DOC_COMMENT]]
DOC_COMMENT:: `///` (~not~<<t-eol>>){star} (<<t-eol>> | <<t-eof>>)

[[t-float,FLOAT]]
FLOAT::
	++[++`-` `pass:[+]`++]++^?^ ++[++`0`-`9`++]++{plus} <<t-float-exp>>^?^ | +
	++[++`-` `pass:[+]`++]++^?^ ++[++`0`-`9`++]++{star} `.` ++[++`0`-`9`++]++{plus} <<t-float-exp>>^?^

[[t-float-exp,FLOAT_EXPONENT]]
FLOAT_EXPONENT:: ++[++`e` `E`++]++ ++[++`-` `pass:[+]`++]++^?^ ++[++`0`-`9`++]++{plus}

[[t-ident,IDENTIFIER]]
IDENTIFIER:: ++[++`A`-`Z` `a`-`z` `+_+`++]++ ++[++`A`-`Z` `a`-`z` `0`-`9` `+_+`++]++{star}

[[t-integer,INTEGER]]
INTEGER::
	`0` | +
	++[++`-` `pass:[+]`++]++^?^ ++[++`1`-`9`++]++ ++[++`0`-`9`++]++{star}

[[t-path,PATH]]
PATH:: (`::`)^?^ <<t-path-seg>> (`::` <<t-path-seg>>){star}

[[t-path-seg,PATH_SEGMENT]]
PATH_SEGMENT:: <<t-ident>> | `super`

[[t-res-loc,RESOURCE_LOCATION]]
RESOURCE_LOCATION::
	<<t-res-loc-char>>{star} `:` <<t-res-loc-char>>{star} (`/` <<t-res-loc-char>>{star}){star} +
	A colon (`:`) must exist to disambiguate this from <<t-ident>>. (e.g. `minecraft:foo`, `:foo`)

[[t-res-loc-char,RES_LOC_CHAR]]
RES_LOC_CHAR:: ++[++`a`-`z` `-` `+_+` `.`++]++

[[t-string,STRING]]
STRING:: `"` ++(++~not~++[++`"` `+\+` <<t-unicode-cc>>++]++ | ++(++`+\+` ++[++`b` `f` `n` `r` `t` `+\+` `"`++]++++))++{star} `"`

[[t-unicode-cc,UNICODE_CC]]
UNICODE_CC:: Unicode control characters.

[[t-typed-number,TYPED_NUMBER]]
TYPED_NUMBER:: <<t-float>> ++[++`b` `B` `d` `D` `f` `F` `l` `L` `s` `S`++]++^?^

****

=== Dispatcher

****
**SYNTAX**

[[s-dispatch,_DispatchStatement_]]
_DispatchStatement_:: `dispatch` <<t-res-loc>> <<s-static-index>>^?^ `to` <<s-type>>

****

A **dispatcher** can be used to dispatch to a specific type from a given index.
It is declared by a <<s-dispatch>> and referenced by a <<s-dispatcher-type>>.

Dispatchers are named after <<t-res-loc>>s, so unlike other values in mcdoc that are named after <<t-ident>>s which requires <<use-statement,being imported>> before they can be used in an external file, dispatchers are inherently global and can be accessed anywhere inside an mcdoc project.

=== Enum

****
**SYNTAX**

[[s-enum,_Enum_]]
_Enum_:: <<s-prelim>> `enum` `(` <<t-enum-type>> `)` <<t-ident>>^?^ <<s-enum-block>>

[[s-enum-block,_EnumBlock_]]
_EnumBlock_::
	`{` `}` | +
	`{` <<s-enum-field>> (`,` <<s-enum-field>>){star} `,`^?^ `}`

[[s-enum-field,_EnumField_]]
_EnumField_:: <<s-prelim>> <<t-ident>> `=` <<t-enum-value>>

'''
**SYNTAX (TOKEN)**

[[t-enum-type,ENUM_TYPE]]
ENUM_TYPE:: `byte` | `short` | `int` | `long` | `string` | `float` | `double`

[[t-enum-value,ENUM_VALUE]]
ENUM_VALUE:: <<t-integer>> | <<t-float>> | <<t-string>>

****

=== Struct

****
**SYNTAX**

[[s-struct,_Struct_]]
_Struct_:: <<s-prelim>> `struct` <<t-ident>>^?^ <<s-type-parameter-block>>^?^ <<s-struct-block>>

[[s-struct-block,_StructBlock_]]
_StructBlock_::
	`{` `}` | +
	`{` <<s-struct-field>> (`,` <<s-struct-field>>){star} `,`^?^ `}`

[[s-struct-field,_StructField_]]
_StructField_::
	<<s-prelim>> <<s-struct-key>> `?`^?^ `:` <<s-type>> | +
	`pass:[...]` <<s-struct-resolvable>>

[[s-struct-key,_StructKey_]]
_StructKey_::
	<<t-string>> | +
	<<t-ident>> | +
	`[` <<s-type>> `]`

[[s-struct-resolvable,_StructResolvable_]]
_StructResolvable_::
	<<t-ident>> | +
	<<s-dispatcher-type>>

[[s-type-parameter-block,_TypeParameterBlock_]]
_TypeParameterBlock_::
	`<` `>` | +
	`<` <<t-ident>> (`,` <<t-ident>>){star} `,`^?^ `>`

****

A **struct** defines the schema of a dictionary-like structure consisting of key-value pairs, like a JSON object or an NBT compound tag.
If a key is duplicated, the type of the later one will override that of the former one.
The optional question mark (`?`) between the key and the colon (`:`) can be added to signal that this field is optional.

.Data pack tag struct
====
[source,rust]
----
struct Tag {
	replace?: boolean,
	values: [string],
}
----
====

The **spread operator** (three dots, `...`) followed by a struct resolvable can be used to reuse fields from another struct.
When there are multiple types provided for the same key, the latest definition will be used.

.Spread syntax
====
[source,rust]
----
struct Player {
	...Mob,
	abilities: Abilities,
	CustomName: (), // Overrides `CustomName` from the `Mob` struct.
}
----
====

A pair of angle brackets (`<` and `>`) can be put after the struct identifier to declare **type parameters**.

.Type parameter
====
[source,rust]
----
struct Tag<V extends string> {
	replace?: boolean,
	values: [V],
}
----
====

=== Type Alias

****
**SYNTAX**
[[s-type-alias,_TypeAlias_]]
_TypeAlias_:: <<s-prelim>> `type` <<t-ident>> <<s-type-parameter-block>>^?^ `=` <<s-type>>
****

=== Use Statement

****
**SYNTAX**
[[s-use,_UseStatement_]]
_UseStatement_:: `export`^?^ `use` <<t-path>> (`as` <<t-ident>>)^?^

****

=== Injection

****
**SYNTAX**
[[s-inject,_Injection_]]
_Injection_:: `inject` (<<s-enum-inject>> | <<s-struct-inject>>)

[[s-enum-inject,_EnumInjection_]]
_EnumInjection_:: `enum` `(` <<t-enum-type>> `)` <<t-path>> <<s-enum-block>>

[[s-struct-inject,_StructInjection_]]
_StructInjection_::
	`struct` <<t-path>> <<s-type-parameter-block>>^?^ <<s-struct-block>> +
	The type parameter block must be the same as the one on the original definition of the injected struct.

****

=== Attribute

****
**SYNTAX**

[[s-attributes,_Attributes_]]
_Attributes_:: <<s-attribute>>{star}

[[s-attribute,_Attribute_]]
_Attribute_::
	`+#[+` <<t-ident>> `]` | +
	`+#[+` <<t-ident>> `=` <<s-type>> `]` | +
	`+#[+` <<t-ident>> <<s-attribute-tree-value>> `]`

[[s-attribute-value,_Value_]]
_Value_:: <<s-type>> | <<s-attribute-tree-value>>

[[s-attribute-tree-value,_TreeValue_]]
_TreeValue_::
	`(` <<s-attribute-tree-body>>^?^ `)` | +
	`[` <<s-attribute-tree-body>>^?^ `]` | +
	`{` <<s-attribute-tree-body>>^?^ `}`

[[s-attribute-tree-body,_TreeBody_]]
_TreeBody_::
	<<s-attribute-positional-values>> `,`^?^ | +
	<<s-attribute-named-values>> `,`^?^ | +
	<<s-attribute-positional-values>> `,` <<s-attribute-named-values>> `,`^?^

[[s-attribute-positional-values,_PositionalValues_]]
_PositionalValues_:: <<s-attribute-value>> (`,` <<s-attribute-value>>){star}

[[s-attribute-named-values,_NamedValues_]]
_NamedValues_:: <<s-attribute-named-value>> (`,` <<s-attribute-named-value>>){star}

[[s-attribute-named-value,_NamedValue_]]
_NamedValue_:: (<<t-ident>> | <<t-string>>) `=` <<s-attribute-value>>
****

.Attribute examples (non-final)
====
All following examples are *syntactically* legal under the current attribute proposal.
Which ones should be *semantically* legal, however, is still under debate.
[source,rust]
----
struct Foo {
	#[id=item]
	id1: string,
	id2: #[id=item] string,
	// id1 and id2 will likely both be supported and have equivalent effects.

	blockStateValue1: (
		#[serializable] string |
		byte | short | int | long | float | double
	),
	#[serialize_to=string]
	blockStateValue2: (string | byte | short | int | long | float | double),

	evilUUID1: (
		#[until("1.16", uuid_string_to_compound)] #[parser=uuid] string |
		#[until("1.17", uuid_compound_to_array)] MostLeastCompound |
		int[] # 4
	),
	#[history{
		(#[parser=uuid] string, until="1.16", updater=uuid_string_to_compound),
		(MostLeastCompound, until="1.17", updater=uuid_compound_to_array),
	}]
	evilUUID2: int[] # 4
}
----
====

=== Type

****
**SYNTAX**

[[s-type,_Type_]]
_Type_:: <<s-attribute>>^?^ <<s-unattributed-type>>

[[s-unattributed-type,_UnattributedType_]]
_UnattributedType_::
	<<s-keyword-type>> | +
	<<s-literal-type>> | +
	<<s-numeric-type>> | +
	<<s-primitive-array-type>> | +
	<<s-list-type>> | +
	<<s-tuple-type>> | +
	<<s-reference-type>> | +
	<<s-dispatcher-type>> | +
	<<s-inline-type>> | +
	<<s-union-type>>

[[s-keyword-type,_KeywordType_]]
_KeywordType_::
	`any` | +
	`boolean` | +
	`string`

[[s-literal-type,_LiteralType_]]
_LiteralType_::
	<<t-string>> |
	<<t-typed-number>>

[[s-numeric-type,_NumericType_]]
_NumericType_::
	`byte` (`+#+` _IntRange_)^?^ | +
	`short` (`+#+` _IntRange_)^?^ | +
	`int` (`+#+` _IntRange_)^?^ | +
	`long` (`+#+` _IntRange_)^?^ | +
	`float` (`+#+` _FloatRange_)^?^ | +
	`double` (`+#+` _FloatRange_)^?^ +
	The optional range defines the range the value must be in.

[[s-primitive-array-type,_PrimitiveArrayType_]]
_PrimitiveArrayType_::
	`byte` (`+#+` _IntRange_)^?^ `[]` (`+#+` _UnsignedIntRange_)^?^ | +
	`int` (`+#+` _IntRange_)^?^ `[]` (`+#+` _UnsignedIntRange_)^?^ | +
	`long` (`+#+` _IntRange_)^?^ `[]` (`+#+` _UnsignedIntRange_)^?^ +
	The first optional range defines the range the value must be in, while the second optional range defines the range of the size of the array.

[[s-list-type,_ListType_]]
_ListType_::
	`[` <<s-type>> `]` (`+#+` _UnsignedIntRange_)^?^ +
	The optional range defines the range of the size of the list.

[[s-tuple-type,_TupleType_]]
_TupleType_::
	`[` <<s-type>> `,` `]` +
	`[` <<s-type>> (`,` <<s-type>>){plus} `,`^?^ `]`

[[s-reference-type,_ReferenceType_]]
_ReferenceType_:: <<t-path>> <<s-index>>{star}

[[s-dispatcher-type,_DispatcherType_]]
_DispatcherType_:: <<t-res-loc>> <<s-index>>{star}

[[s-index,_Index_]]
_Index_:: <<s-static-index>> | <<s-dynamic-index>>

[[s-static-index,_StaticIndex_]]
_StaticIndex_::
	`[` <<t-static-index-key>> (`,` <<t-static-index-key>>){star} `]` +
	Multiple keys can be put inside the brackets to access multiple types from the target.
+
.Access multiple types from a dispatcher
====
`minecraft:entity[ender_dragon, wither]` -> Produces a union of the type for the Ender Dragon and the type for the Wither.
====

[[s-dynamic-index,_DynamicIndex_]]
_DynamicIndex_:: `[[` <<t-accessor>> `]]`

[[s-inline-type,_InlineType_]]
_InlineType_::
	<<s-enum>> | +
	<<s-struct>>

[[s-union-type,_UnionType_]]
_UnionType_::
	`(` `)` <<s-index>>{star} | +
	`(` <<s-type>> (`|` <<s-type>>){star} `)` <<s-index>>{star} +
	A pair of empty parentheses removes this field definition from the struct.

'''

**SYNTAX (TOKEN)**

[[t-static-index-key,STATIC_INDEX_KEY]]
STATIC_INDEX_KEY:: <<t-ident>> | <<t-string>> | <<t-res-loc>>

[[t-accessor,ACCESSOR]]
ACCESSOR:: <<t-accessor-key>> (`.` <<t-accessor-key>>){star}

[[t-accessor-key,ACCESSOR_KEY]]
ACCESSOR_KEY:: <<t-ident>> | <<t-string>> | `super` | `key`

'''

Indices can access a type from a dispatcher or get a field type from an existing struct, both statically (i.e. the user provides the key literally in the mcdoc file) and dynamically (i.e. the user specifies a way to get the key from the given data structure at runtime).

.Indices
====
[source,rust]
----
struct Foo {
	id: string,
	cow_data: minecraft:entity[cow], // <1>
	dynamic_entity_data: minecraft:entity[[id]], // <2>
	command: minecraft:block[command_block][Command], // <3>
	dynamic_memories: minecraft:entity[[id]][Brain][memories], // <4>
}
----
<1> Static index on a dispatcher.
<2> Dynamic index on a dispatcher.
<3> Static index on a dispatcher, followed by a static index on a struct.
<4> Dynamic index on a dispatcher, followed by two static indices on two structs.
====

****

== Branding

"Mcdoc" is a common noun and should only have its first letter capitalized when it's grammatically required to.

== Credits

The mcdoc format takes heavy inspiration from the https://github.com/Yurihaia/nbtdoc-rs[nbtdoc format] created by https://github.com/Yurihaia[Yurihaia], licensed under the https://github.com/Yurihaia/nbtdoc-rs/blob/master/LICENSE-MIT[MIT License].

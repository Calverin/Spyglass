:page-layout: default
:page-title: Mcdoc
:page-parent: Home
:page-nav_order: 1

Mcdoc is a schema format for describing data structures used by Minecraft, including its CODECs, JSONs, and NBTs.

This document defines:

* The syntax and semantics of the mcdoc format.
* How mcdoc should be used to validate JSON and NBT values. For NBT values, this document further specifies how they should be validated strictly and loosely.

Although mcdocs may technically be able to describe the format of a lot of other languages, how those languages should be validated by mcdoc is not concerned by this document.

== Project root

Normally, the **workspace** (the directory where the mcdoc interpreter operates: for command line tools, this could be the working directory; for code editors like VS Code, this could be the root directory shown in the sidebar explorer) is considered as the **root** of a mcdoc project.

If, however, there exists both a file named `pack.mcmeta` and a folder named `mcdoc` under the workspace, the `mcdoc` folder will be considered as the root instead.

== Syntax syntax

:plus: pass:n[^pass:[+]^]
:star: pass:n[^+*+^]

Here is the syntax used by this document to describe the syntax of mcdoc -- syntax syntax, if you want to call it that.
You can safely ignore this section and all blocks titled "`**SYNTAX**`" if you are not interested in writing a parser for the mcdoc language.

[[tb-syntax-syntax]]
.Syntax syntax
|===
|Symbol |Meaning

|`str` |Literal `str`
|A{star} |A repeated zero or more times
|A{plus} |A repeated one or more times
|A^?^ |A repeated zero or one times
|A \| B |Either A or B
|++[++`A` `B` `C`++]++ |One of the literals `A`, `B`, or `C`
|++[++`A`-`Z`++]++ |Any literal from `A` to `Z`
|(A) |General grouping
|~not~A |Anything not A
|A~pass:n[except: B]~ |A except B
|A~pass:n[lookahead: B]~ |A followed by B, but only consumes A
|A~pass:n[nochild: B]~ |A but B should not be a child of it
|<<token-rule,NAME>> |A referenced <<token-rule>>
|<<parser-rule,_Name_>> |A referenced <<parser-rule>>
|===

[[token-rule,token rule]]
A token rule syntax cannot have any whitespaces (spaces, tabs, CRs, or LFs) or tokens in between the individual parts.

[[parser-rule,parser rule]]
A parser rule syntax can have whitespaces and <<t-comments>> in between.

== Comments

****
**SYNTAX (TOKEN)**

[[t-comments,COMMENTS]]
<<t-comments>>:: <<t-comment>>{star}

[[t-comment,COMMENT]]
<<t-comment>>:: `//` ~pass:n[lookahead: ~not~`/`]~ (~not~<<t-eol>>){star} (<<t-eol>> | <<t-eof>>)

[[t-eol,EOL]]
<<t-eol>>:: End of line: CR (Unicode `U+000D`) or LF (Unicode `U+000A`).

[[t-eof,EOF]]
<<t-eof>>:: End of file.
****

Comments can be used in mcdoc to write information that can be seen only by other users viewing/editing your mcdoc files.
They are ignored by a mcdoc interpreter.

To write a comment, simply put down two forward slashes (`//`) -- everything following them, until the end of the line, is treated as part of the comment.
They can be put anywhere where a whitespace is allowed.
Comments, however, cannot start with triple slashes (`///`), as that's reserved for <<doc-comments>>.

.Comments
====
[source,rust]
----
// This is a comment.
struct Foo {
	Bar: boolean, // This is another one.
}
----
====

== Doc comments

****
**SYNTAX**

[[s-prelim,_Prelim_]]
<<s-prelim>>:: <<t-doc-comments>> <<s-attributes>>

'''

**SYNTAX (TOKEN)**

[[t-doc-comments,DOC_COMMENTS]]
<<t-doc-comments>>:: <<t-doc-comment>>{star}

[[t-doc-comment,DOC_COMMENT]]
<<t-doc-comment>>:: `///` (~not~<<t-eol>>){star} (<<t-eol>> | <<t-eof>>)
****

Doc comments are similar to comments syntax-wise -- they start with triple slashes (`///`) instead.
A block of doc comments can provide human-readable documentation for the component right after it to users of your mcdoc files.
Unlike regular comments, doc comments can only be put in front of enum definitions, enum fields, struct definitions, struct fields, and type aliases, as part of <<prelim>>s.

The text content of a doc comment block should be treated as a MarkDown content, with the leading triple slashes stripped.

.Doc comments
====
[source,rust]
----
/// This doc comment describes the struct Foo.
/// External tools, like VS Code, may show this block of text when the user hovers over the name "Foo".
struct Foo {
	/// This is another doc comment describing the field "Bar".
	Bar: boolean, // This is just a regular comment because it only starts with two slashes.
}
----
====

TIP: As the content of a doc comment block is treated as MarkDown, certain characters might have special meaning.
For example, if you write `<foo>` inside the doc comment, it might disappear when being shown to a user, as it may get interperted as an XML tag by a MarkDown parser.
Escaping those special characters with a backslash (`\`) (e.g. `\<foo>`) will fix this.

== Integer

****
**SYNTAX (TOKEN)**

[[t-integer,INTEGER]]
<<t-integer>>::
	`0` | +
	++[++`-` `pass:[+]`++]++^?^ ++[++`1`-`9`++]++ ++[++`0`-`9`++]++{star}
****

An integer represents a whole number.

.Integers
====
[source,rust]
----
0
+123
-456
----
====

== Float

****
**SYNTAX (TOKEN)**

[[t-float,FLOAT]]
<<t-float>>::
	++[++`-` `pass:[+]`++]++^?^ ++[++`0`-`9`++]++{plus} <<t-float-exp>>^?^ | +
	++[++`-` `pass:[+]`++]++^?^ ++[++`0`-`9`++]++{star} `.` ++[++`0`-`9`++]++{plus} <<t-float-exp>>^?^

[[t-float-exp,FLOAT_EXPONENT]]
<<t-float-exp>>:: ++[++`e` `E`++]++ ++[++`-` `pass:[+]`++]++^?^ ++[++`0`-`9`++]++{plus}
****

A float represents a decimal number.
Scientific notation may be used with the letter `e` (case-insensitive).

.Floats
====
[source,rust,subs="+quotes"]
----
1
+1.2
-1.2e3 // -1.2Ã—10^3^
----
====

== Typed Number

****
**SYNTAX (TOKEN)**

[[t-typed-number,TYPED_NUMBER]]
<<t-typed-number>>::
	<<t-integer>> ++[++`b` `B` `l` `L` `s` `S`++]++^?^ | +
	<<t-float>> ++[++`d` `D` `f` `F`++]++^?^
****

A typed number is similar to a number used in SNBTs syntax-wise.
It's a normal number followed by a suffix indicating its type:

.Suffix table
|===
|Suffix (case-insensitive) |Type

|`b` |Byte
|`s` |Short
|`L` |Long
|`f` |Float
|`d` |Double
|(No suffix, integer) |Integer
|(No suffix, decimal) |Double
|===

.Typed numbers
====
[source,rust]
----
1b      // Byte 1
1       // Integer 1
1.2     // Double 1.2
1.2d    // Double 1.2
1.2e1f  // Float 12
----
====

== Number range

****
**SYNTAX (TOKEN)**

[[t-float-range,FLOAT_RANGE]]
<<t-float-range>>::
	`+..+`^?^ <<t-float>> | +
	<<t-float>> `+..+` <<t-float>>^?^

[[t-int-range,INT_RANGE]]
<<t-int-range>>::
	`+..+`^?^ <<t-integer>> | +
	<<t-integer>> `+..+` <<t-integer>>^?^
****

A number range represents a range of number.
It follows the same syntax for ranges used in Minecraft commands.
There are two types of ranges in mcdoc: float ranges, which consist of <<float>>s, and integer ranges, which consists of <<integer>>s.

.Number ranges
====
[source,rust]
----
1      // Exactly 1
1..1   // Exactly 1
1..2   // Between 1 and 2 (inclusive on ends)
4.2..  // Greater than or equal to 4.2
..9.1  // Smaller than or equal to 9.1
----
====

== String

****
**SYNTAX (TOKEN)**

[[t-string,STRING]]
<<t-string>>:: `"` ++(++~not~++[++`"` `+\+` <<t-unicode-cc>>++]++ | ++(++`+\+` ++[++`b` `f` `n` `r` `t` `+\+` `"`++]++++))++{star} `"`

[[t-unicode-cc,UNICODE_CC]]
<<t-unicode-cc>>:: Unicode control characters.
****

A string represents a sequence of characters.
It must be surrounded by double quotation marks (`"`).
Certain characters need to be escaped by a backslash (`\`).

.Escape characters
|===
|Escape sequence |Meaning

|`\"` |A double quotation mark (`"`, Unicode `U+0022`)
|`\\` |A backslash (`\`, Unicode `U+005C`)
|`\b` |A backspace (Unicode `U+0008`)
|`\f` |A form feed (Unicode `U+000C`)
|`\n` |A newline (Unicode `U+000A`)
|`\r` |A carriage return (Unicode `U+000D`)
|`\t` |A tab (Unicode `U+0009`)
|===

.Strings
====
[source,rust,subs="+quotes"]
----
"foo"            // A string representing `foo`
"bar\"qux\\baz"  // A string representing `bar"qux\baz`
----
====

== Resource location

****
**SYNTAX (TOKEN)**

[[t-res-loc,RES_LOC]]
<<t-res-loc>>:: <<t-res-loc-char>>{star} `:` <<t-res-loc-char>>{star} (`/` <<t-res-loc-char>>{star}){star}

[[t-res-loc-char,RES_LOC_CHAR]]
<<t-res-loc-char>>:: ++[++`a`-`z` `0`-`9` `-` `+_+` `.`++]++
****

A resource location is similar to the resource location from Minecraft syntax-wise, except that a colon (`:`) must exist to disambiguate this from an <<identifier>>.

.Resource locations
====
[source,rust,subs="+quotes"]
----
minecraft:foo
:foo  // This also means `minecraft:foo`, and is actually legal in Minecraft.
spyglassmc:bar
----
====

== Identifier

****
**SYNTAX (TOKEN)**

[[t-ident,IDENTIFIER]]
<<t-ident>>:: (++[++`A`-`Z` `a`-`z` `+_+`++]++ ++[++`A`-`Z` `a`-`z` `0`-`9` `+_+`++]++{star})~pass:n[except: <<t-keywords>>]~

[[t-keywords,KEYWORDS]]
<<t-keywords>>:: `key` | `super`
****

An identifier is a name given to a type definition in mcdoc.
It can contain any alphanumeric characters and the underscore (`_`), but must not start with a numeric character (`0`-`9`).

It also must not be named after a list of keywords:

* `key`
* `super`

NOTE: We might extend supported characters for identifiers to any character in the Unicode categories "`Uppercase letter (Lu)`", "`Lowercase letter (Ll)`", "`Titlecase letter (Lt)`", "`Modifier letter (Lm)`", "`Other letter (Lo)`", or "`Letter number (Nl)`" in the future.

.Identifiers
====
[source,rust,subs="+quotes"]
----
struct *Foo* { // `Foo` is an identifier.
	*B_1*: boolean, // `B_1` is an identifier.
}
----
====

== Path

****
**SYNTAX (TOKEN)**

[[t-path,PATH]]
<<t-path>>:: (`::`)^?^ <<t-path-seg>> (`::` <<t-path-seg>>){star}

[[t-path-seg,PATH_SEGMENT]]
<<t-path-seg>>:: <<t-ident>> | `super`
****

A path is used to locate a type definition across the mcdoc project.
A sequence of two colons (`::`) is used as the *path separater*.

If a path starts with the path separater, it is an *absolute path* and will be resolved from the <<project-root>>.
Otherwise it is a *relative path* and will be resolved from the absolute path of the current file.

The absolute path of a file is determined by connecting the names of all its parent folders up until the root and the file's own name (excluding the `.mcdoc` file extension) with the path separater, prepended by the path separater, with a special case for files named `mod.mcdoc` -- they will not be part of their paths.

The absolute path of a type definition is the absolute path of the file where it resides joined with the identifier of the type definition by the path separater.

If multiple files/type definitions ended up having the same path, only the earliest loaded one will take effect; all subsequent ones should be warned and ignored by the mcdoc interpreter.

For relative paths, the keyword `super` may be used to move up one level from the current absolute path.

.Paths
====
[source]
----
/
	foo.mcdoc <1>
	foo/
		bar.mcdoc <2>
		mod.mcdoc <3>
	qux.mcdoc <4>
----
<1> The absolute path of this file is `::foo`.
<2> The absolute path of this file is `::foo::bar`.
<3> The absolute path of this file is `::foo` instead of `::foo::mod`, as files named `mod.mcdoc` are special. This has the same path as <1>, and as <1> is shallower in the file structure, it is loaded first, meaning <3> is ignored in favor of <1> and a warning should be given.

If the content of `/foo/bar.mcdoc` is

[source,rust]
----
struct Foo {} <1>

type Bar = super::super::qux::Something <2>
----
<1> The absolute path for struct `Foo` is `::foo::bar::Foo`
<2> The absolute path for type alias `Bar` is `::foo::bar::Bar`. +
The relative path is interpreted as follows:
+
. Absolute path of the residing file (`/foo/bar.mcdoc`) is `::foo::bar`. The given relative path is `super::super::qux::Something`.
. Encounters keyword `super`, moves one level up to `::foo`. Remaining relative path is `super::qux::Something`.
. Encounters keyword `super`, moves one level up to `::`. Remaining relative path is `qux::Something`.
. Encounters identifier `qux`, moves down to `::qux`. Remaining relative path is `Something`.
. Encounters identifier `Something`, moves down to `::qux::Something`. Relative path has been resolved.
. The type alias `Bar` therefore points to the type definition named `Something` in file `/qux.mcdoc`.
====

== File Structure

****
**SYNTAX**

[[s-file,_File_]]
<<s-file>>:: (<<s-dispatch>> | <<s-enum>> | <<s-struct>> | <<s-type-alias>> | <<s-use>> | <<s-inject>>){star}

****

An mcdoc is made of dispatch statements, enum definitions, struct definitions, type aliases, use statements, and injections.

== Dispatcher

****
**SYNTAX**

[[s-dispatch,_DispatchStatement_]]
<<s-dispatch>>:: `dispatch` <<t-res-loc>> <<s-index-body>>~pass:n[nochild: <<s-dynamic-index>>]~ `to` <<s-type>>

****

A **dispatcher** can be used to dispatch to a specific type from a given index.
Each case of a dispatcher can be declared by a <<s-dispatch>>.

Dispatchers are named after <<t-res-loc>>s, so unlike other values in mcdoc that are named after <<t-ident>>s which require <<use-statement,being imported>> before they can be used in an external file, dispatchers are inherently global and can be accessed anywhere inside an mcdoc project.

When a non-existing index is used to access a dispatcher, a union consisting of all types registered under the dispatcher is generated as a fallback case at runtime.
The union is marked with the "nonexhaustive" metadata.

== Enum

****
**SYNTAX**

[[s-enum,_Enum_]]
<<s-enum>>:: <<s-prelim>> `enum` `(` <<t-enum-type>> `)` <<t-ident>>^?^ <<s-enum-block>>

[[s-enum-block,_EnumBlock_]]
<<s-enum-block>>::
	`{` `}` | +
	`{` <<s-enum-field>> (`,` <<s-enum-field>>){star} `,`^?^ `}`

[[s-enum-field,_EnumField_]]
<<s-enum-field>>:: <<s-prelim>> <<t-ident>> `=` <<t-enum-value>>

'''
**SYNTAX (TOKEN)**

[[t-enum-type,ENUM_TYPE]]
<<t-enum-type>>:: `byte` | `short` | `int` | `long` | `string` | `float` | `double`

[[t-enum-value,ENUM_VALUE]]
<<t-enum-value>>::
	<<t-typed-number>> | <<t-string>> +
	Although <<t-typed-number>> is expected as the value for enums, the user can write the numbers without the proper suffixes as the mcdoc interpreter is able to infer the proper type from the enum definition.

****

== Struct

****
**SYNTAX**

[[s-struct,_Struct_]]
<<s-struct>>:: <<s-prelim>> `struct` <<t-ident>>^?^ <<s-type-parameter-block>>^?^ <<s-struct-block>>

[[s-type-parameter-block,_TypeParameterBlock_]]
<<s-type-parameter-block>>::
	`<` `>` | +
	`<` <<t-ident>> (`,` <<t-ident>>){star} `,`^?^ `>`

[[s-struct-block,_StructBlock_]]
<<s-struct-block>>::
	`{` `}` | +
	`{` <<s-struct-field>> (`,` <<s-struct-field>>){star} `,`^?^ `}`

[[s-struct-field,_StructField_]]
<<s-struct-field>>::
	<<s-prelim>> <<s-struct-key>> `?`^?^ `:` <<s-type>> | +
	`+...+` <<s-type>> +
	For the spreading syntax (`+...+`), if the type after the spread operator cannot be resolved as a struct type, only the attributes on the type will be copied over to the current struct.

[[s-struct-key,_StructKey_]]
<<s-struct-key>>::
	<<t-string>> | +
	<<t-ident>> | +
	`[` <<s-type>> `]`

****

A **struct** defines the schema of a dictionary-like structure consisting of key-value pairs, like a JSON object or an NBT compound tag.
If a key is duplicated, the type of the later one will override that of the former one.
The optional question mark (`?`) between the key and the colon (`:`) can be added to signal that this field is optional.

.Data pack tag struct
====
[source,rust]
----
struct Tag {
	replace?: boolean,
	values: [string],
}
----
====

The **spread operator** (three dots, `+...+`) followed by a struct resolvable can be used to reuse fields from another struct.
When there are multiple types provided for the same key, the latest definition will be used.

.Spread syntax
====
[source,rust]
----
struct Player {
	...Mob,
	abilities: Abilities,
	CustomName: (), // Overrides `CustomName` from the `Mob` struct.
}
----
====

A pair of angle brackets (`<` and `>`) can be put after the struct identifier to declare **type parameters**.

.Type parameter
====
[source,rust]
----
struct Tag<V extends string> {
	replace?: boolean,
	values: [V],
}
----
====

== Type Alias

****
**SYNTAX**
[[s-type-alias,_TypeAlias_]]
<<s-type-alias>>:: <<s-prelim>> `type` <<t-ident>> <<s-type-parameter-block>>^?^ `=` <<s-type>>
****

== Use Statement

****
**SYNTAX**
[[s-use,_UseStatement_]]
<<s-use>>:: `export`^?^ `use` <<t-path>> (`as` <<t-ident>>)^?^

****

== Injection

****
**SYNTAX**
[[s-inject,_Injection_]]
<<s-inject>>:: `inject` (<<s-enum-inject>> | <<s-struct-inject>>)

[[s-enum-inject,_EnumInjection_]]
<<s-enum-inject>>:: `enum` `(` <<t-enum-type>> `)` <<t-path>> <<s-enum-block>>

[[s-struct-inject,_StructInjection_]]
<<s-struct-inject>>::
	`struct` <<t-path>> <<s-type-parameter-block>>^?^ <<s-struct-block>> +
	The type parameter block must be the same as the one on the original definition of the injected struct.

****

== Attribute

****
**SYNTAX**

[[s-attributes,_Attributes_]]
<<s-attributes>>:: <<s-attribute>>{star}

[[s-attribute,_Attribute_]]
<<s-attribute>>::
	`+#[+` <<t-ident>> `]` | +
	`+#[+` <<t-ident>> `=` <<s-type>> `]` | +
	`+#[+` <<t-ident>> <<s-attribute-tree-value>> `]`

[[s-attribute-value,_Value_]]
<<s-attribute-value>>:: <<s-type>> | <<s-attribute-tree-value>>

[[s-attribute-tree-value,_TreeValue_]]
<<s-attribute-tree-value>>::
	`(` <<s-attribute-tree-body>>^?^ `)` | +
	`[` <<s-attribute-tree-body>>^?^ `]` | +
	`{` <<s-attribute-tree-body>>^?^ `}`

[[s-attribute-tree-body,_TreeBody_]]
<<s-attribute-tree-body>>::
	<<s-attribute-positional-values>> `,`^?^ | +
	<<s-attribute-named-values>> `,`^?^ | +
	<<s-attribute-positional-values>> `,` <<s-attribute-named-values>> `,`^?^

[[s-attribute-positional-values,_PositionalValues_]]
<<s-attribute-positional-values>>:: <<s-attribute-value>> (`,` <<s-attribute-value>>){star}

[[s-attribute-named-values,_NamedValues_]]
<<s-attribute-named-values>>:: <<s-attribute-named-value>> (`,` <<s-attribute-named-value>>){star}

[[s-attribute-named-value,_NamedValue_]]
<<s-attribute-named-value>>:: (<<t-ident>> | <<t-string>>) `=` <<s-attribute-value>>
****

.Attribute examples (non-final)
====
All following examples are *syntactically* legal under the current attribute proposal.
Which ones should be *semantically* legal, however, is still under debate.
[source,rust]
----
struct Foo {
	#[id=item]
	id1: string,
	id2: #[id=item] string,
	// id1 and id2 will likely both be supported and have equivalent effects.

	blockStateValue1: (
		#[serializable] string |
		byte | short | int | long | float | double
	),
	#[serialize_to=string]
	blockStateValue2: (string | byte | short | int | long | float | double),

	evilUUID1: (
		#[until("1.16", uuid_string_to_compound)] #[parser=uuid] string |
		#[until("1.17", uuid_compound_to_array)] MostLeastCompound |
		int[] # 4
	),
	#[history{
		(#[parser=uuid] string, until="1.16", updater=uuid_string_to_compound),
		(MostLeastCompound, until="1.17", updater=uuid_compound_to_array),
	}]
	evilUUID2: int[] # 4
}
----
====

== Type

A type is an essential part of the mcdoc format.
It defines a schema that the actual data value must fit in to be valid.

NOTE: Mcdoc may be used to describe the format of a wide range of data.
This section will only define how JSON data and SNBT data should be validated.

****
**SYNTAX**

[[s-type,_Type_]]
<<s-type>>::
	<<s-attributes>> <<s-unattributed-type>> <<s-index-body>>{star}

[[s-unattributed-type,_UnattributedType_]]
<<s-unattributed-type>>::
	<<s-keyword-type>> | +
	<<s-literal-type>> | +
	<<s-numeric-type>> | +
	<<s-primitive-array-type>> | +
	<<s-list-type>> | +
	<<s-tuple-type>> | +
	<<t-path>> | +
	<<t-res-loc>> | +
	<<s-inline-type>> | +
	<<s-union-type>>
****

=== `boolean` type
****
**SYNTAX**

[[s-keyword-type,_KeywordType_]]
<<s-keyword-type>>::
	`any` | +
	`boolean` | +
	`string`
****

The `boolean` type indicates a boolean value (`false` or `true`) is expected.

.Valid values for the `boolean` type
|===
|Format |Examples |Notes

|JSON |`false`, `true` |-
|SNBT (strict) |`false`, `true`, `0b`, `1b` |NBT doesn't have real boolean values -- it uses byte numbers for that purpose instead. `false` and `true` are simply aliases for `0b` and `1b`, respectively.
|SNBT (loose) |`false`, `true`, `0b`, `1b`, `0`, `1`, `2s`, `1.7` ... |Per method `net/minecraft/nbt/NbtCompound#getBoolean` (yarn mappings), any NBT values can be read as a boolean. A non-numeric value is equivalent to `false`, while a numeric value is false if and only if it is a `0` after being converted to a byte number.
|===

=== Indexing on a type

****
**SYNTAX**

[[s-index-body,_IndexBody_]]
<<s-index-body>>:: `[` <<s-index>> (`,` <<s-index>>){star} `,`^?^ `]` +
Multiple indices can be put inside the brackets to access multiple types from the target.
+
.Access multiple types from a dispatcher
====
`minecraft:entity[ender_dragon, wither]` -> Produces a union of the type for the ender dragon and the type for the wither.

`minecraft:entity[[id], allay]` -> Produces a union of the type for the entity at `id` dynamically and the allay.
====

[[s-index,_Index_]]
<<s-index>>:: <<t-static-index-key>> | <<s-dynamic-index>> +

[[s-dynamic-index,_DynamicIndex_]]
<<s-dynamic-index>>:: `[` <<t-accessor>> `]`

'''

**SYNTAX (TOKEN)**

[[t-static-index-key,STATIC_INDEX_KEY]]
<<t-static-index-key>>:: <<t-ident>> | <<t-string>> | <<t-res-loc>>

[[t-accessor,ACCESSOR]]
<<t-accessor>>:: <<t-accessor-key>> (`.` <<t-accessor-key>>){star}

[[t-accessor-key,ACCESSOR_KEY]]
<<t-accessor-key>>:: <<t-ident>> | <<t-string>> | `super` | `key`
****

****
**SYNTAX**

[[s-literal-type,_LiteralType_]]
<<s-literal-type>>::
	<<t-string>> |
	<<t-typed-number>>

[[s-numeric-type,_NumericType_]]
<<s-numeric-type>>::
	`byte` (`+#+` <<t-int-range>>)^?^ | +
	`short` (`+#+` <<t-int-range>>)^?^ | +
	`int` (`+#+` <<t-int-range>>)^?^ | +
	`long` (`+#+` <<t-int-range>>)^?^ | +
	`float` (`+#+` <<t-float-range>>)^?^ | +
	`double` (`+#+` <<t-float-range>>)^?^ +
	The optional range defines the range the value must be in.

[[s-primitive-array-type,_PrimitiveArrayType_]]
<<s-primitive-array-type>>::
	`byte` (`+#+` <<t-int-range>>)^?^ `[]` (`+#+` <<t-int-range>>)^?^ | +
	`int` (`+#+` <<t-int-range>>)^?^ `[]` (`+#+` <<t-int-range>>)^?^ | +
	`long` (`+#+` <<t-int-range>>)^?^ `[]` (`+#+` <<t-int-range>>)^?^ +
	The first optional range defines the range the value must be in, while the second optional range defines the range of the size of the array.

[[s-list-type,_ListType_]]
<<s-list-type>>::
	`[` <<s-type>> `]` (`+#+` <<t-int-range>>)^?^ +
	The optional range defines the range of the size of the list.

[[s-tuple-type,_TupleType_]]
<<s-tuple-type>>::
	`[` <<s-type>> `,` `]` +
	`[` <<s-type>> (`,` <<s-type>>){plus} `,`^?^ `]`

[[s-inline-type,_InlineType_]]
<<s-inline-type>>::
	<<s-enum>> | +
	<<s-struct>>

[[s-union-type,_UnionType_]]
<<s-union-type>>::
	`(` `)` | +
	`(` <<s-type>> (`|` <<s-type>>){star} `)` +
	A pair of empty parentheses removes this field definition from the struct.

'''

Indices can access a type from a dispatcher or get a field type from an existing struct, both statically (i.e. the user provides the key literally in the mcdoc file) and dynamically (i.e. the user specifies a way to get the key from the given data structure at runtime).

.Indices
====
[source,rust]
----
struct Foo {
	id: string,
	cow_data: minecraft:entity[cow], // <1>
	dynamic_entity_data: minecraft:entity[[id]], // <2>
	command: minecraft:block[command_block][Command], // <3>
	dynamic_memories: minecraft:entity[[id]][Brain][memories], // <4>
}
----
<1> Static index on a dispatcher.
<2> Dynamic index on a dispatcher.
<3> Static index on a dispatcher, followed by a static index on a struct.
<4> Dynamic index on a dispatcher, followed by two static indices on two structs.
====

****

== Procedures

NOTE: Under this section, <<procedures,`PascalCase`>> represents a type in the procedure, <<procedures,`camelCase`>> represents a procedure, and `_italic_` represents a variable.

[[p-Boolean,`Boolean`]]
=== <<p-Boolean>>
A boolean value. Either `false` or `true`.

[[p-String,`String`]]
=== <<p-String>>
A string value.

[[p-None,`None`]]
=== <<p-None>>
An abstract representation of an empty value (`null` / `undefined` / `None` / `nil` / `Nothing`, etc.).

[[p-Option,`Option`]]
=== <<p-Option>><``T``>
An abstract representation of empty value handling.
Implementations are free to choose their way of handling empty values.

For the purpose of this specification, an <<p-Option>><``T``> is either <<p-None>> or an instance of `T`.
All operations done on an <<p-Option>><``T``> is assumed to be done only when it is an instance of `T`.
Its value is kept as <<p-None>> if it's already a <<p-None>>.

=== <<t-ident>>
* [[p-ident-asString,`asString`]] <<t-ident>>.<<p-ident-asString>>(): <<p-String>>. Returns the string value of the identifier token.

=== <<t-string>>
* [[p-string-asString,`asString`]] <<t-string>>.<<p-string-asString>>(): <<p-String>>. Returns the string value of the string token.

=== <<t-res-loc>>
* [[p-res-loc-asFullString,`asFullString`]] <<t-res-loc>>.<<p-res-loc-asFullString>>(): <<p-String>>. Returns the full string representation of the resource location. The namespace part should always be kept.
* [[p-res-loc-asShortString,`asShortString`]] <<t-res-loc>>.<<p-res-loc-asShortString>>(): <<p-String>>. Returns the short string representation of the resource location. The namespace part should be omitted if it's the default namespace (`minecraft:`).

[[p-DereferencedType,`DereferencedType`]]
=== <<p-DereferencedType>>
A dereferenced type is a <<s-type>>~pass:n[nochild: <<t-path>>]~ .

[[p-RuntimeValue,`RuntimeValue`]]
=== <<p-RuntimeValue>>
A runtime value is an abstract representation of a data in memory that can be checked against by mcdoc.
It could be a deserialized JSON data or a deserialized NBT data, for example.

It should support the following basic operations, but it is up to implementations to determine how those operations should work exactly for a specific type of a runtime value:

* [[p-RuntimeValue-asString,`asString`]] <<p-RuntimeValue>>.<<p-RuntimeValue-asString>>(): <<p-Option>><<<p-String>>>. Returns the string value (not the string representation) of this runtime value if applicable. Otherwise returns <<p-None>>.
* [[p-RuntimeValue-getKeyOnParent,`getKeyOnParent`]] <<p-RuntimeValue>>.<<p-RuntimeValue-getKeyOnParent>>(): <<p-Option>><<<p-RuntimeValue>>>. If this value is a child of a parent value, returns its key on the parent if applicable. Otherwise returns <<p-None>>.
* [[p-RuntimeValue-getParent,`getParent`]] <<p-RuntimeValue>>.<<p-RuntimeValue-getParent>>(): <<p-Option>><<<p-RuntimeValue>>>. Returns the value's parent value if applicable. Otherwise returns <<p-None>>.
* [[p-RuntimeValue-getValue,`getValue`]] <<p-RuntimeValue>>.<<p-RuntimeValue-getValue>>(`_key_`: <<p-String>>): <<p-Option>><<<p-RuntimeValue>>>. Returns the value corresponding to `_key_` under this value if applicable. Otherwise returns <<p-None>>.

[[p-dereference,`dereference`]]
=== <<p-dereference>> (`_type_`: <<s-type>>): <<p-DereferencedType>>
This procedure dereferences a <<s-type>>.

. If `_type_` consists of a <<t-path>>, then
.. Destruct `_attributes_`: <<s-attributes>>, `_path_`: <<t-path>>, and `_indices_`: <<s-index>>{star} from `_type_`.
.. Let `_type_`: <<s-type>> be the type pointed to by `_path_` or an empty union if `_path_` points to undefined, attributed by `_attributes_` and indexed by `_indices_`.
.. Returns <<p-dereference>>(`_type_`) recursively.
. Returns `_type_`.

[[p-resolveIndex,`resolveIndex`]]
=== <<p-resolveIndex>> (`_type_`: <<s-type>>, `_value_`: <<p-RuntimeValue>>): <<p-DereferencedType>>
. Let `_type_`: <<p-DereferencedType>> be <<p-dereference>>(`_type_`).
. Destruct `_attributes_`: <<s-attributes>>, `_unattributedType_`: <<s-unattributed-type>>~pass:n[except: <<t-path>>]~, and `_indices_`: <<s-index>>{star} from `_type_`.
. If `_indices_` is empty, returns `_type_`.
. For each `_index_`: <<s-index>> of `_indices_`,
.. If `_index_` is <<s-dynamic-index>>, let `_index_`: <<t-static-index-key>> be <<p-resolveDynamicIndex>>(`_index_`, `_value_`).
.. Pattern match `_unattributedType_`, and stores the result to `_resultType_`: <<s-type>>:
... <<t-res-loc>> -> TBD
... <<s-struct>> -> The type of the field corresponding to key `_index_` on struct `_type_` or an empty union if the field doesn't exist, attributed by `_attributes_`.
... <<s-union-type>> ->
.... For each `_element_`: <<s-type>> of `_type_`,
..... Duh.
... +*+ -> An empty union.
.. Let `_resultType_`: <<p-DereferencedType>> be <<p-dereference>>(`_resultType_`).
.. Let `_unattributedType_`: <<s-unattributed-type>>~pass:n[except: <<t-path>>]~ be `_resultType_` attributed by `_attributes_`. // FIXME: Attributes merging
.. Let `_value_` be the runtime value corresponding to the key `_index_` under `_value_` or `undefined` if no such value exists.
. Let `_type_`: <<p-DereferencedType>> be <<p-dereference>>(`_type_`).
. Return `_type_`.

[[p-resolveDynamicIndex,`resolveDynamicIndex`]]
=== <<p-resolveDynamicIndex>> (`_index_`: <<s-dynamic-index>>, `_value_`: <<p-RuntimeValue>>): <<p-Option>><<<p-String>>>
. Destruct `_accessor_`: <<t-accessor>> from `_index_`.
. Destruct `_keys_`: <<t-accessor-key>>{plus} from `_accessor_`.
. Let `_v_`: <<p-Option>><<<p-RuntimeValue>>> be `_value_`.
. For each `_key_`: <<t-accessor-key>> of `_keys_`,
.. If `_v_` is <<p-None>>, break.
.. Pattern match `_key_` for
... `super` -> set `_v_` to `_v_`.<<p-RuntimeValue-getParent>>().
... `key` -> set `_v_` to `_v_`.<<p-RuntimeValue-getKeyOnParent>>().
... <<t-ident>> -> set `_v_` to `_v_`.<<p-RuntimeValue-getValue>>(`_key_`.<<p-ident-asString>>()).
... <<t-string>> -> set `_v_` to `_v_`.<<p-RuntimeValue-getValue>>(`_key_`.<<p-string-asString>>()).
. Return `_v_`.<<p-RuntimeValue-asString>>().

== Branding

"Mcdoc" is a common noun and should only have its first letter capitalized when it's grammatically required to (e.g. at the beginning of the sentence).

== Credits

The mcdoc format takes heavy inspiration from the https://github.com/Yurihaia/nbtdoc-rs[nbtdoc format] created by https://github.com/Yurihaia[Yurihaia], licensed under the https://github.com/Yurihaia/nbtdoc-rs/blob/master/LICENSE-MIT[MIT License].
https://github.com/misode[Misode], https://github.com/MulverineX[MulverineX], and https://github.com/NeunEinser[NeunEinser] also have provided valuable feedback for the mcdoc format.

This documentation is written with https://docs.asciidoctor.org/asciidoc/latest/[AsciiDoc].

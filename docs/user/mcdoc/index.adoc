:page-layout: default
:page-title: Mcdoc
:page-parent: Home
:page-nav_order: 1

Mcdoc is a schema format for describing data structures used by Minecraft, including its CODECs, JSONs, and NBTs.

== Project Structure

The root folder of a mcdoc project must contain a `pack.mcmeta` file and a `mcdoc` folder, where all mcdoc files are stored.
The file content of `pack.mcmeta` is not concerned by the mcdoc specification.

.File structure
====
[source]
----
Root/
	mcdoc/
		bar/
			mod.mcdoc
			qux.mcdoc
		foo.mcdoc
	pack.mcmeta
----
====

== Syntax

:plus: pass:n[^pass:[+]^]
:star: pass:n[^+*+^]

[[tb-syntax-syntax]]
.Syntax syntax
|===
|Symbol |Meaning

|`str` |Literal `str`
|A{star} |A repeated zero or more times
|A{plus} |A repeated one or more times
|A^?^ |A repeated zero or one times
|A \| B |Either A or B
|++[++`A` `B` `C`++]++ |One of the literals `A`, `B`, or `C`
|++[++`A`-`Z`++]++ |Any literal from `A` to `Z`
|(A) |General grouping
|~not~A |Anything not A
|A~pass:n[except: B]~ |A except B
|A~pass:n[lookahead: B]~ |A followed by B, but only consumes A
|A~pass:n[nochild: B]~ |A but B should not be a child of it
|<<tb-syntax-syntax,NAME>> |A referenced <<token-rule>>
|<<tb-syntax-syntax,_Name_>> |A referenced <<parser-rule>>
|===

[[token-rule,token rule]]
A token rule syntax cannot have any whitespaces (spaces, tabs, CRs, or LFs) or tokens in between the individual parts.

[[parser-rule,parser rule]]
A parser rule syntax can have whitespaces and <<t-comments>> in between.

=== File Structure

****
**SYNTAX**

[[s-file,_File_]]
<<s-file>>:: (<<s-dispatch>> | <<s-enum>> | <<s-struct>> | <<s-type-alias>> | <<s-use>> | <<s-inject>>){star}

****

=== Common Syntax

****
**SYNTAX**

[[s-prelim,_Prelim_]]
<<s-prelim>>:: <<t-doc-comments>> <<s-attributes>>

'''
**SYNTAX (TOKEN)**

[[t-comments,COMMENTS]]
<<t-comments>>:: <<t-comment>>{star}

[[t-comment,COMMENT]]
<<t-comment>>:: `//` ~pass:n[lookahead: ~not~`/`]~ (~not~<<t-eol>>){star} (<<t-eol>> | <<t-eof>>)

[[t-eol,EOL]]
<<t-eol>>:: End of line: CR (Unicode `U+000D`) or LF (Unicode `U+000A`).

[[t-eof,EOF]]
<<t-eof>>:: End of file.

[[t-doc-comments,DOC_COMMENTS]]
<<t-doc-comments>>:: <<t-doc-comment>>{star}

[[t-doc-comment,DOC_COMMENT]]
<<t-doc-comment>>:: `///` (~not~<<t-eol>>){star} (<<t-eol>> | <<t-eof>>)

[[t-float,FLOAT]]
<<t-float>>::
	++[++`-` `pass:[+]`++]++^?^ ++[++`0`-`9`++]++{plus} <<t-float-exp>>^?^ | +
	++[++`-` `pass:[+]`++]++^?^ ++[++`0`-`9`++]++{star} `.` ++[++`0`-`9`++]++{plus} <<t-float-exp>>^?^

[[t-float-exp,FLOAT_EXPONENT]]
<<t-float-exp>>:: ++[++`e` `E`++]++ ++[++`-` `pass:[+]`++]++^?^ ++[++`0`-`9`++]++{plus}

[[t-ident,IDENTIFIER]]
<<t-ident>>:: ++[++`A`-`Z` `a`-`z` `+_+`++]++ ++[++`A`-`Z` `a`-`z` `0`-`9` `+_+`++]++{star}

[[t-integer,INTEGER]]
<<t-integer>>::
	`0` | +
	++[++`-` `pass:[+]`++]++^?^ ++[++`1`-`9`++]++ ++[++`0`-`9`++]++{star}

[[t-path,PATH]]
<<t-path>>:: (`::`)^?^ <<t-path-seg>> (`::` <<t-path-seg>>){star}

[[t-path-seg,PATH_SEGMENT]]
<<t-path-seg>>:: <<t-ident>> | `super`

[[t-res-loc,RESOURCE_LOCATION]]
<<t-res-loc>>::
	<<t-res-loc-char>>{star} `:` <<t-res-loc-char>>{star} (`/` <<t-res-loc-char>>{star}){star} +
	A colon (`:`) must exist to disambiguate this from <<t-ident>>. (e.g. `minecraft:foo`, `:foo`)

[[t-res-loc-char,RES_LOC_CHAR]]
<<t-res-loc-char>>:: ++[++`a`-`z` `0`-`9` `-` `+_+` `.`++]++

[[t-string,STRING]]
<<t-string>>:: `"` ++(++~not~++[++`"` `+\+` <<t-unicode-cc>>++]++ | ++(++`+\+` ++[++`b` `f` `n` `r` `t` `+\+` `"`++]++++))++{star} `"`

[[t-unicode-cc,UNICODE_CC]]
<<t-unicode-cc>>:: Unicode control characters.

[[t-typed-number,TYPED_NUMBER]]
<<t-typed-number>>:: <<t-float>> ++[++`b` `B` `d` `D` `f` `F` `l` `L` `s` `S`++]++^?^

****

=== Dispatcher

****
**SYNTAX**

[[s-dispatch,_DispatchStatement_]]
<<s-dispatch>>:: `dispatch` <<t-res-loc>> <<s-static-index>>^?^ `to` <<s-type>>

****

A **dispatcher** can be used to dispatch to a specific type from a given index.
Each case of a dispatcher can be declared by a <<s-dispatch>> and referenced by a <<s-dispatcher-type>>.

Dispatchers are named after <<t-res-loc>>s, so unlike other values in mcdoc that are named after <<t-ident>>s which require <<use-statement,being imported>> before they can be used in an external file, dispatchers are inherently global and can be accessed anywhere inside an mcdoc project.

When a non-existing index is used to access a dispatcher, a union consisting of all types registered under the dispatcher is generated as a fallback case at runtime.
The union is marked with the "nonexhaustive" metadata.

=== Enum

****
**SYNTAX**

[[s-enum,_Enum_]]
<<s-enum>>:: <<s-prelim>> `enum` `(` <<t-enum-type>> `)` <<t-ident>>^?^ <<s-enum-block>>

[[s-enum-block,_EnumBlock_]]
<<s-enum-block>>::
	`{` `}` | +
	`{` <<s-enum-field>> (`,` <<s-enum-field>>){star} `,`^?^ `}`

[[s-enum-field,_EnumField_]]
<<s-enum-field>>:: <<s-prelim>> <<t-ident>> `=` <<t-enum-value>>

'''
**SYNTAX (TOKEN)**

[[t-enum-type,ENUM_TYPE]]
<<t-enum-type>>:: `byte` | `short` | `int` | `long` | `string` | `float` | `double`

[[t-enum-value,ENUM_VALUE]]
<<t-enum-value>>:: <<t-integer>> | <<t-float>> | <<t-string>>

****

=== Struct

****
**SYNTAX**

[[s-struct,_Struct_]]
<<s-struct>>:: <<s-prelim>> `struct` <<t-ident>>^?^ <<s-type-parameter-block>>^?^ <<s-struct-block>>

[[s-type-parameter-block,_TypeParameterBlock_]]
<<s-type-parameter-block>>::
	`<` `>` | +
	`<` <<t-ident>> (`,` <<t-ident>>){star} `,`^?^ `>`

[[s-struct-block,_StructBlock_]]
<<s-struct-block>>::
	`{` `}` | +
	`{` <<s-struct-field>> (`,` <<s-struct-field>>){star} `,`^?^ `}`

[[s-struct-field,_StructField_]]
<<s-struct-field>>::
	<<s-prelim>> <<s-struct-key>> `?`^?^ `:` <<s-type>> | +
	`+...+` <<s-struct-resolvable>>

[[s-struct-key,_StructKey_]]
<<s-struct-key>>::
	<<t-string>> | +
	<<t-ident>> | +
	`[` <<s-type>> `]`

[[s-struct-resolvable,_StructResolvable_]]
<<s-struct-resolvable>>::
	<<t-ident>> | +
	<<s-dispatcher-type>>

****

A **struct** defines the schema of a dictionary-like structure consisting of key-value pairs, like a JSON object or an NBT compound tag.
If a key is duplicated, the type of the later one will override that of the former one.
The optional question mark (`?`) between the key and the colon (`:`) can be added to signal that this field is optional.

.Data pack tag struct
====
[source,rust]
----
struct Tag {
	replace?: boolean,
	values: [string],
}
----
====

The **spread operator** (three dots, `+...+`) followed by a struct resolvable can be used to reuse fields from another struct.
When there are multiple types provided for the same key, the latest definition will be used.

.Spread syntax
====
[source,rust]
----
struct Player {
	...Mob,
	abilities: Abilities,
	CustomName: (), // Overrides `CustomName` from the `Mob` struct.
}
----
====

A pair of angle brackets (`<` and `>`) can be put after the struct identifier to declare **type parameters**.

.Type parameter
====
[source,rust]
----
struct Tag<V extends string> {
	replace?: boolean,
	values: [V],
}
----
====

=== Type Alias

****
**SYNTAX**
[[s-type-alias,_TypeAlias_]]
<<s-type-alias>>:: <<s-prelim>> `type` <<t-ident>> <<s-type-parameter-block>>^?^ `=` <<s-type>>
****

=== Use Statement

****
**SYNTAX**
[[s-use,_UseStatement_]]
<<s-use>>:: `export`^?^ `use` <<t-path>> (`as` <<t-ident>>)^?^

****

=== Injection

****
**SYNTAX**
[[s-inject,_Injection_]]
<<s-inject>>:: `inject` (<<s-enum-inject>> | <<s-struct-inject>>)

[[s-enum-inject,_EnumInjection_]]
<<s-enum-inject>>:: `enum` `(` <<t-enum-type>> `)` <<t-path>> <<s-enum-block>>

[[s-struct-inject,_StructInjection_]]
<<s-struct-inject>>::
	`struct` <<t-path>> <<s-type-parameter-block>>^?^ <<s-struct-block>> +
	The type parameter block must be the same as the one on the original definition of the injected struct.

****

=== Attribute

****
**SYNTAX**

[[s-attributes,_Attributes_]]
<<s-attributes>>:: <<s-attribute>>{star}

[[s-attribute,_Attribute_]]
<<s-attribute>>::
	`+#[+` <<t-ident>> `]` | +
	`+#[+` <<t-ident>> `=` <<s-type>> `]` | +
	`+#[+` <<t-ident>> <<s-attribute-tree-value>> `]`

[[s-attribute-value,_Value_]]
<<s-attribute-value>>:: <<s-type>> | <<s-attribute-tree-value>>

[[s-attribute-tree-value,_TreeValue_]]
<<s-attribute-tree-value>>::
	`(` <<s-attribute-tree-body>>^?^ `)` | +
	`[` <<s-attribute-tree-body>>^?^ `]` | +
	`{` <<s-attribute-tree-body>>^?^ `}`

[[s-attribute-tree-body,_TreeBody_]]
<<s-attribute-tree-body>>::
	<<s-attribute-positional-values>> `,`^?^ | +
	<<s-attribute-named-values>> `,`^?^ | +
	<<s-attribute-positional-values>> `,` <<s-attribute-named-values>> `,`^?^

[[s-attribute-positional-values,_PositionalValues_]]
<<s-attribute-positional-values>>:: <<s-attribute-value>> (`,` <<s-attribute-value>>){star}

[[s-attribute-named-values,_NamedValues_]]
<<s-attribute-named-values>>:: <<s-attribute-named-value>> (`,` <<s-attribute-named-value>>){star}

[[s-attribute-named-value,_NamedValue_]]
<<s-attribute-named-value>>:: (<<t-ident>> | <<t-string>>) `=` <<s-attribute-value>>
****

.Attribute examples (non-final)
====
All following examples are *syntactically* legal under the current attribute proposal.
Which ones should be *semantically* legal, however, is still under debate.
[source,rust]
----
struct Foo {
	#[id=item]
	id1: string,
	id2: #[id=item] string,
	// id1 and id2 will likely both be supported and have equivalent effects.

	blockStateValue1: (
		#[serializable] string |
		byte | short | int | long | float | double
	),
	#[serialize_to=string]
	blockStateValue2: (string | byte | short | int | long | float | double),

	evilUUID1: (
		#[until("1.16", uuid_string_to_compound)] #[parser=uuid] string |
		#[until("1.17", uuid_compound_to_array)] MostLeastCompound |
		int[] # 4
	),
	#[history{
		(#[parser=uuid] string, until="1.16", updater=uuid_string_to_compound),
		(MostLeastCompound, until="1.17", updater=uuid_compound_to_array),
	}]
	evilUUID2: int[] # 4
}
----
====

=== Type

****
**SYNTAX**

[[s-type,_Type_]]
<<s-type>>::
	<<s-attributes>> <<s-unattributed-type>> <<s-index>>{star}

[[s-unattributed-type,_UnattributedType_]]
<<s-unattributed-type>>::
	<<s-keyword-type>> | +
	<<s-literal-type>> | +
	<<s-numeric-type>> | +
	<<s-primitive-array-type>> | +
	<<s-list-type>> | +
	<<s-tuple-type>> | +
	<<t-path>> | +
	<<s-dispatcher-type>> | +
	<<s-inline-type>> | +
	<<s-union-type>>

[[s-keyword-type,_KeywordType_]]
<<s-keyword-type>>::
	`any` | +
	`boolean` | +
	`string`

[[s-literal-type,_LiteralType_]]
<<s-literal-type>>::
	<<t-string>> |
	<<t-typed-number>>

[[s-numeric-type,_NumericType_]]
<<s-numeric-type>>::
	`byte` (`+#+` _IntRange_)^?^ | +
	`short` (`+#+` _IntRange_)^?^ | +
	`int` (`+#+` _IntRange_)^?^ | +
	`long` (`+#+` _IntRange_)^?^ | +
	`float` (`+#+` _FloatRange_)^?^ | +
	`double` (`+#+` _FloatRange_)^?^ +
	The optional range defines the range the value must be in.

[[s-primitive-array-type,_PrimitiveArrayType_]]
<<s-primitive-array-type>>::
	`byte` (`+#+` _IntRange_)^?^ `[]` (`+#+` _UnsignedIntRange_)^?^ | +
	`int` (`+#+` _IntRange_)^?^ `[]` (`+#+` _UnsignedIntRange_)^?^ | +
	`long` (`+#+` _IntRange_)^?^ `[]` (`+#+` _UnsignedIntRange_)^?^ +
	The first optional range defines the range the value must be in, while the second optional range defines the range of the size of the array.

[[s-list-type,_ListType_]]
<<s-list-type>>::
	`[` <<s-type>> `]` (`+#+` _UnsignedIntRange_)^?^ +
	The optional range defines the range of the size of the list.

[[s-tuple-type,_TupleType_]]
<<s-tuple-type>>::
	`[` <<s-type>> `,` `]` +
	`[` <<s-type>> (`,` <<s-type>>){plus} `,`^?^ `]`

[[s-dispatcher-type,_DispatcherType_]]
<<s-dispatcher-type>>:: <<t-res-loc>> <<s-index>>

[[s-inline-type,_InlineType_]]
<<s-inline-type>>::
	<<s-enum>> | +
	<<s-struct>>

[[s-union-type,_UnionType_]]
<<s-union-type>>::
	`(` `)` <<s-index>>{star} | +
	`(` <<s-type>> (`|` <<s-type>>){star} `)` <<s-index>>{star} +
	A pair of empty parentheses removes this field definition from the struct.

[[s-index,_Index_]]
<<s-index>>:: <<s-static-index>> | <<s-dynamic-index>>

[[s-static-index,_StaticIndex_]]
<<s-static-index>>::
	`[` <<t-static-index-key>> (`,` <<t-static-index-key>>){star} `]` +
	Multiple keys can be put inside the brackets to access multiple types from the target.
+
.Access multiple types from a dispatcher
====
`minecraft:entity[ender_dragon, wither]` -> Produces a union of the type for the Ender Dragon and the type for the Wither.
====

[[s-dynamic-index,_DynamicIndex_]]
<<s-dynamic-index>>:: `[[` <<t-accessor>> `]]`

'''

**SYNTAX (TOKEN)**

[[t-static-index-key,STATIC_INDEX_KEY]]
<<t-static-index-key>>:: <<t-ident>> | <<t-string>> | <<t-res-loc>>

[[t-accessor,ACCESSOR]]
<<t-accessor>>:: <<t-accessor-key>> (`.` <<t-accessor-key>>){star}

[[t-accessor-key,ACCESSOR_KEY]]
<<t-accessor-key>>:: <<t-ident>> | <<t-string>> | `super` | `key`

'''

Indices can access a type from a dispatcher or get a field type from an existing struct, both statically (i.e. the user provides the key literally in the mcdoc file) and dynamically (i.e. the user specifies a way to get the key from the given data structure at runtime).

.Indices
====
[source,rust]
----
struct Foo {
	id: string,
	cow_data: minecraft:entity[cow], // <1>
	dynamic_entity_data: minecraft:entity[[id]], // <2>
	command: minecraft:block[command_block][Command], // <3>
	dynamic_memories: minecraft:entity[[id]][Brain][memories], // <4>
}
----
<1> Static index on a dispatcher.
<2> Dynamic index on a dispatcher.
<3> Static index on a dispatcher, followed by a static index on a struct.
<4> Dynamic index on a dispatcher, followed by two static indices on two structs.
====

****

== Procedures

NOTE: Under this section, <<procedures,`PascalCase`>> represents a type in the procedure, <<procedures,`camelCase`>> represents a procedure, and `_italic_` represents a variable.

[[p-DereferencedType,`DereferencedType`]]
=== <<p-DereferencedType>>
A dereferenced type is a <<s-type>>~pass:n[nochild: <<t-path>>]~ .

[[p-value,`RuntimeValue`]]
=== <<p-value>>
A runtime value is an abstract representation of a data in memory that can be checked against by mcdoc.
It could be a deserialized JSON data or a deserialized NBT data, for example.

[[p-dereference,`dereference`]]
=== <<p-dereference>> (`_type_`: <<s-type>>): <<p-DereferencedType>>
This procedure dereferences a <<s-type>>.

. If `_type_` consists of a <<t-path>>, then
.. Destruct `_attributes_`: <<s-attributes>>, `_path_`: <<t-path>>, and `_indices_`: <<s-index>>{star} from `_type_`.
.. Let `_type_`: <<s-type>> be the type pointed to by `_path_` or an empty union if `_path_` points to undefined, attributed by `_attributes_` and indexed by `_indices_`.
.. Returns <<p-dereference>>(`_type_`) recursively.
. Returns `_type_`.

[[p-resolveIndex,`resolveIndex`]]
=== <<p-resolveIndex>> (`_type_`: <<s-type>>, `_value_`: <<p-value>>): <<p-DereferencedType>>
. Let `_type_`: <<p-DereferencedType>> be <<p-dereference>>(`_type_`).
. Destruct `_attributes_`: <<s-attributes>>, `_type_`: <<s-unattributed-type>>~pass:n[except: <<t-path>>]~, and `_indices_`: <<s-index>>{star} from `_type_`.
. For each `_index_`: <<s-index>> of `_indices_`,
.. If `_index_` is <<s-dynamic-index>>, let `_index_`: <<s-static-index>> be <<p-resolveDynamicIndex>>(`_index_`, `_value_`).
.. Let `_type_`: <<s-type>> be the value resulted from pattern matching `_type_` to
... <<s-dispatcher-type>> -> TBD
... <<s-struct>> -> The type of the field corresponding to key `_index_` on struct `_type_` or an empty union if the field doesn't exist, attributed by `_attributes_`.
... <<s-union-type>> ->
.... For each `_element_`: <<s-type>> of `_type_`,
..... Duh.
... An empty union attributed by `_attributes_`.
.. Let `_type_`: <<p-DereferencedType>> be <<p-dereference>>(`_type_`).
.. Let `_value_` be the runtime value corresponding to the key `_index_` under `_value_` or `undefined` if no such value exists.
. Let `_type_`: <<p-DereferencedType>> be <<p-dereference>>(`_type_`).
. Returns `_type_`.

== Branding

"Mcdoc" is a common noun and should only have its first letter capitalized when it's grammatically required to.

== Credits

The mcdoc format takes heavy inspiration from the https://github.com/Yurihaia/nbtdoc-rs[nbtdoc format] created by https://github.com/Yurihaia[Yurihaia], licensed under the https://github.com/Yurihaia/nbtdoc-rs/blob/master/LICENSE-MIT[MIT License].
https://github.com/misode[Misode], https://github.com/MulverineX[MulverineX], and https://github.com/NeunEinser[NeunEinser] also have provided valuable feedback for the mcdoc format.

This documentation is written with https://docs.asciidoctor.org/asciidoc/latest/[AsciiDoc].

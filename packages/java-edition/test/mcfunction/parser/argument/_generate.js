import fs from 'fs'
import path from 'path'
import url from 'url'
import { CommandArgumentTestSuites } from './_suites.js'

// Generates test files for each command argument parser with test suites from `./_suites.js`.
// It is super laggy to have a giant 80k-line snapshot file, hence why we separated the tests to multiple files.

const ShouldGenerate = true // Prevent from mis-triggering.
const ProduceExtraChildren = [
	'minecraft:block_predicate',
	'minecraft:block_state',
	'minecraft:entity',
	'minecraft:item_predicate',
	'minecraft:item_stack',
	'minecraft:score_holder',
]

/**
 * @param {string} parser 
 * @returns {string}
 */
function template(parser) {
	return `// This file is generated by \`_generate.js\`. Do not modify by hand.
import { showWhitespaceGlyph, testParser } from '@spyglassmc/core/test-out/utils.js'
import { argument } from '@spyglassmc/java-edition/lib/mcfunction/parser/index.js'
import type { ArgumentTreeNode } from '@spyglassmc/java-edition/lib/mcfunction/tree/index.js'
import { describe, it } from 'mocha'
import snapshot from 'snap-shot-it'
// @ts-expect-error
import { CommandArgumentTestSuites } from '@spyglassmc/java-edition/test/mcfunction/parser/argument/_suites.js'
// @ts-expect-error
import { meta } from '@spyglassmc/java-edition/test/mcfunction/parser/argument/_meta.js'

describe('mcfunction argument ${parser}', () => {
	for (const { content, properties } of CommandArgumentTestSuites['${parser}']!) {
		const treeNode: ArgumentTreeNode = {
			type: 'argument',
			parser: '${parser}',
			properties,
		}
		for (const string of content) {
			it(\`Parse "\${showWhitespaceGlyph(string)}"\${properties ? \` with \${JSON.stringify(properties)}\` : ''}\`, () => {
				snapshot(testParser(argument(treeNode)!, string, { project: { meta }${ProduceExtraChildren.includes(parser) ? ', removeTopLevelChildren: true' : ''} }))
			})
		}
	}
})
`
}

if (ShouldGenerate) {
	for (const parser of Object.keys(CommandArgumentTestSuites)) {
		fs.writeFileSync(
			path.join(url.fileURLToPath(new URL('.', import.meta.url)), `${parser.replace(/[:_](\w)/g, (_, c) => c.toUpperCase())}.generated.spec.ts`),
			template(parser),
			{ encoding: 'utf-8' }
		)
	}
}
